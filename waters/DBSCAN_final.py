import os
import re
import numpy as np
from sklearn.cluster import DBSCAN
from sklearn.neighbors import NearestNeighbors
import pandas as pd
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# --- Configuration ---
# Set the input and output directories as provided in the request.
INPUT_DIR = r"C:\Users\ifige\Documents\GitHub\SZMAP\szmap_unique_waters"
OUTPUT_DIR = r"C:\Users\ifige\Documents\GitHub\SZMAP\DBSCAN_results"
OUTPUT_FILENAME_SDF = "clustered_waters.sdf"
OUTPUT_FILENAME_LABELS = "cluster_labels.txt"
OUTPUT_FILENAME_CSV = "clustered_data.csv"
OUTPUT_FILENAME_PNG = "cluster_plot.png"
OUTPUT_PATH_SDF = os.path.join(OUTPUT_DIR, OUTPUT_FILENAME_SDF)
OUTPUT_PATH_LABELS = os.path.join(OUTPUT_DIR, OUTPUT_FILENAME_LABELS)
OUTPUT_PATH_CSV = os.path.join(OUTPUT_DIR, OUTPUT_FILENAME_CSV)
OUTPUT_PATH_PNG = os.path.join(OUTPUT_DIR, OUTPUT_FILENAME_PNG)

# New output filenames for separated data
OUTPUT_FILENAME_SDF_CLUSTERS = "clustered_waters_no_noise.sdf"
OUTPUT_FILENAME_SDF_NOISE = "noise_only.sdf"
OUTPUT_FILENAME_PNG_CLUSTERS = "clustered_waters_no_noise.png"
OUTPUT_FILENAME_PNG_NOISE = "noise_only.png"
OUTPUT_PATH_SDF_CLUSTERS = os.path.join(OUTPUT_DIR, OUTPUT_FILENAME_SDF_CLUSTERS)
OUTPUT_PATH_SDF_NOISE = os.path.join(OUTPUT_DIR, OUTPUT_FILENAME_SDF_NOISE)
OUTPUT_PATH_PNG_CLUSTERS = os.path.join(OUTPUT_DIR, OUTPUT_FILENAME_PNG_CLUSTERS)
OUTPUT_PATH_PNG_NOISE = os.path.join(OUTPUT_DIR, OUTPUT_FILENAME_PNG_NOISE)

# New output file for cluster stats and energy analysis
OUTPUT_FILENAME_STATS_TXT = "cluster_stats.txt"
OUTPUT_PATH_STATS_TXT = os.path.join(OUTPUT_DIR, OUTPUT_FILENAME_STATS_TXT)

# New SDF filenames for mean and representative molecules
OUTPUT_FILENAME_SDF_MEAN = "mean_cluster_waters.sdf"
OUTPUT_PATH_SDF_MEAN = os.path.join(OUTPUT_DIR, OUTPUT_FILENAME_SDF_MEAN)
OUTPUT_FILENAME_SDF_REPRESENTATIVE = "representative_cluster_waters.sdf"
OUTPUT_PATH_SDF_REPRESENTATIVE = os.path.join(OUTPUT_DIR, OUTPUT_FILENAME_SDF_REPRESENTATIVE)

# DBSCAN parameters. These are crucial and may need to be tuned
# based on your data. 'eps' is the maximum distance between two samples
# for one to be considered as in the neighborhood of the other. 'min_samples'
# is the number of samples in a neighborhood for a point to be considered
# as a core point.
# You will likely need to adjust these values.
# IMPORTANT: Use the K-distance graph generated by this script to help
# determine a better EPS value. Look for the 'elbow' in the plot.
EPS = 0.5  # A reasonable starting value in Angstroms for water molecules
MIN_SAMPLES = 150  # Minimum number of waters to form a cluster


# --- Data Processing Functions ---

def parse_sdf_file(filepath):
    """
    Parses a single SDF file to extract water molecule data.
    It returns a list of dictionaries, where each dictionary contains
    the raw text block of a water molecule, the coordinates of its
    oxygen atom, and its szmap_neut_diff_free_energy and szmap_probability values.
    """
    waters = []
    try:
        with open(filepath, 'r') as f:
            file_content = f.read()

        # Split the file content by the '$$$$' separator
        water_blocks = file_content.split('$$$$\n')

        for block in water_blocks:
            if not block.strip():
                continue

            lines = block.strip().split('\n')

            # Find the line containing the oxygen atom ('O')
            oxygen_line = None
            for line in lines:
                if ' O ' in line:  # Ensure we match the atom type 'O'
                    oxygen_line = line
                    break

            # Find the line containing the free energy
            energy_value = None
            probability_value = None
            for i, line in enumerate(lines):
                if "> <szmap_neut_diff_free_energy>" in line:
                    if i + 1 < len(lines):
                        try:
                            energy_value = float(lines[i + 1].strip())
                        except (ValueError, IndexError):
                            energy_value = None
                if "> <szmap_probability>" in line:
                    if i + 1 < len(lines):
                        try:
                            probability_value = float(lines[i + 1].strip())
                        except (ValueError, IndexError):
                            probability_value = None

            if oxygen_line:
                # Extract the coordinates from the oxygen atom line.
                # The coordinates are the first three non-whitespace values.
                coords = [float(x) for x in re.findall(r'[-+]?\d+\.\d+', oxygen_line)[:3]]

                waters.append({
                    'text': block.strip(),
                    'coords': coords,
                    'energy': energy_value,
                    'probability': probability_value
                })
    except FileNotFoundError:
        print(f"Error: File not found at {filepath}")
    except Exception as e:
        print(f"An error occurred while parsing {filepath}: {e}")

    return waters


def collect_all_water_data(input_dir):
    """
    Iterates through all .sdf files in the input directory,
    parses each one, and aggregates all water data.
    """
    all_waters = []
    try:
        for filename in os.listdir(input_dir):
            if filename.endswith(".sdf"):
                filepath = os.path.join(input_dir, filename)
                print(f"Parsing file: {filepath}")
                all_waters.extend(parse_sdf_file(filepath))
    except FileNotFoundError:
        print(f"Error: Input directory not found at {input_dir}")
    except Exception as e:
        print(f"An error occurred while listing files in {input_dir}: {e}")

    return all_waters


def perform_dbscan(coords, eps, min_samples):
    """
    Performs DBSCAN clustering on the provided coordinates.
    Returns the cluster labels for each data point.
    """
    db = DBSCAN(eps=eps, min_samples=min_samples)
    labels = db.fit_predict(coords)
    return labels


def write_clustered_sdf(waters, labels, output_path):
    """
    Writes the clustered water molecules to a new SDF file.
    The cluster label is added as a new data field for each molecule.
    A label of -1 indicates a noise point.
    """
    # Ensure the output directory exists
    os.makedirs(os.path.dirname(output_path), exist_ok=True)

    with open(output_path, 'w') as f:
        for i, water in enumerate(waters):
            f.write(water['text'])
            f.write('\n')

            # Add the cluster label to the SDF block
            cluster_id = labels[i]
            f.write(f"> <cluster_id>\n{cluster_id}\n\n")

            f.write('$$$$\n')
    print(f"\nClustering results saved to: {output_path}")


def write_raw_labels(labels, output_path):
    """
    Writes the raw DBSCAN cluster labels to a text file.
    """
    # Ensure the output directory exists
    os.makedirs(os.path.dirname(output_path), exist_ok=True)

    with open(output_path, 'w') as f:
        f.write("# This file contains the raw, default output of the DBSCAN algorithm\n")
        f.write("# as an array of cluster labels. Each number corresponds to a water\n")
        f.write("# molecule in the order they were processed.\n")
        f.write("# A label of -1 indicates a 'noise' point.\n\n")
        f.write(f"{list(labels)}\n")
    print(f"Raw cluster labels saved to: {output_path}")


def write_cluster_csv(coords, labels, output_path):
    """
    Saves the coordinates and cluster labels to a CSV file.
    """
    try:
        df = pd.DataFrame(coords, columns=['x', 'y', 'z'])
        df['cluster_id'] = labels
        os.makedirs(os.path.dirname(output_path), exist_ok=True)
        df.to_csv(output_path, index=False)
        print(f"Cluster data saved to CSV: {output_path}")
    except Exception as e:
        print(f"An error occurred while writing CSV file: {e}")


def plot_clusters(coords, labels, output_path):
    """
    Generates a 3D scatter plot of the clustered data and saves it to a PNG file.
    """
    try:
        fig = plt.figure(figsize=(10, 8))
        ax = fig.add_subplot(111, projection='3d')

        # Color points based on their cluster ID
        unique_labels = set(labels)
        # Use a more distinct colormap for a large number of clusters
        colors = plt.cm.turbo(np.linspace(0, 1, len(unique_labels)))

        for k, col in zip(unique_labels, colors):
            if k == -1:
                # Black color for noise points
                col = 'k'
                marker_size = 6
            else:
                marker_size = 20

            class_member_mask = (labels == k)

            xyz = coords[class_member_mask]

            ax.scatter(xyz[:, 0], xyz[:, 1], xyz[:, 2], c=[col], s=marker_size, label=f'Cluster {k}')

        ax.set_title(f'DBSCAN Clustering (eps={EPS}, min_samples={MIN_SAMPLES})')
        ax.set_xlabel('X')
        ax.set_ylabel('Y')
        ax.set_zlabel('Z')

        os.makedirs(os.path.dirname(output_path), exist_ok=True)
        plt.savefig(output_path)
        print(f"Cluster plot saved to PNG: {output_path}")
        plt.close(fig)

    except Exception as e:
        print(f"An error occurred while plotting: {e}")


def plot_k_distance(coords, min_samples, output_dir):
    """
    Generates and saves a K-distance graph to help determine the optimal eps value.
    The 'elbow' in the graph indicates a good eps value.
    """
    try:
        neigh = NearestNeighbors(n_neighbors=min_samples)
        distances, indices = neigh.fit(coords).kneighbors(coords)
        distances = np.sort(distances[:, min_samples - 1], axis=0)

        plt.figure(figsize=(12, 6))
        plt.plot(distances)
        plt.title(f'K-Distance Graph (k = {min_samples})')
        plt.xlabel('Data Points sorted by distance')
        plt.ylabel(f'{min_samples}-th Nearest Neighbor Distance')
        plt.grid(True)

        plot_path = os.path.join(output_dir, 'k_distance_graph.png')
        os.makedirs(os.path.dirname(plot_path), exist_ok=True)
        plt.savefig(plot_path)
        plt.close()
        print(f"\nK-distance graph saved to: {plot_path}")
        print("INSTRUCTION: Open this image and look for the 'elbow' (the point where the graph sharply bends).")
        print("The corresponding Y-axis value is a good candidate for your 'EPS' parameter.")
        print(f"Consider adjusting MIN_SAMPLES to explore different k-values.")

    except Exception as e:
        print(f"An error occurred while plotting the K-distance graph: {e}")


def write_clustered_sdf_no_noise(waters, labels, output_path):
    """
    Writes only the clustered water molecules (label != -1) to a new SDF file.
    """
    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    with open(output_path, 'w') as f:
        for i, water in enumerate(waters):
            if labels[i] != -1:
                f.write(water['text'])
                f.write('\n')
                f.write(f"> <cluster_id>\n{labels[i]}\n\n")
                f.write('$$$$\n')
    print(f"Clustered waters (without noise) saved to: {output_path}")


def write_noise_sdf(waters, labels, output_path):
    """
    Writes only the noise water molecules (label == -1) to a new SDF file.
    """
    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    with open(output_path, 'w') as f:
        for i, water in enumerate(waters):
            if labels[i] == -1:
                f.write(water['text'])
                f.write('\n')
                f.write(f"> <cluster_id>\n{labels[i]}\n\n")
                f.write('$$$$\n')
    print(f"Noise waters saved to: {output_path}")


def plot_clusters_without_noise(coords, labels, output_path):
    """
    Generates a 3D scatter plot of only the clustered points and saves it to a PNG file.
    """
    try:
        fig = plt.figure(figsize=(10, 8))
        ax = fig.add_subplot(111, projection='3d')

        clustered_mask = labels != -1
        clustered_coords = coords[clustered_mask]
        clustered_labels = labels[clustered_mask]

        if len(clustered_labels) > 0:
            unique_labels = sorted(list(set(clustered_labels)))
            colors = plt.cm.turbo(np.linspace(0, 1, len(unique_labels)))

            for i, k in enumerate(unique_labels):
                class_member_mask = (clustered_labels == k)
                xyz = clustered_coords[class_member_mask]
                ax.scatter(xyz[:, 0], xyz[:, 1], xyz[:, 2], c=[colors[i]], s=20, label=f'Cluster {k}')
        else:
            ax.text2D(0.5, 0.5, "No clusters found (all points are noise)", ha='center', va='center',
                      transform=ax.transAxes)

        ax.set_title(f'DBSCAN Clusters Only (eps={EPS}, min_samples={MIN_SAMPLES})')
        ax.set_xlabel('X')
        ax.set_ylabel('Y')
        ax.set_zlabel('Z')

        os.makedirs(os.path.dirname(output_path), exist_ok=True)
        plt.savefig(output_path)
        print(f"Cluster plot (without noise) saved to PNG: {output_path}")
        plt.close(fig)
    except Exception as e:
        print(f"An error occurred while plotting clusters without noise: {e}")


def plot_noise_only(coords, labels, output_path):
    """
    Generates a 3D scatter plot of only the noise points and saves it to a PNG file.
    """
    try:
        fig = plt.figure(figsize=(10, 8))
        ax = fig.add_subplot(111, projection='3d')

        noise_mask = labels == -1
        noise_coords = coords[noise_mask]

        ax.scatter(noise_coords[:, 0], noise_coords[:, 1], noise_coords[:, 2], c='k', s=6)

        ax.set_title(f'DBSCAN Noise Points Only (eps={EPS}, min_samples={MIN_SAMPLES})')
        ax.set_xlabel('X')
        ax.set_ylabel('Y')
        ax.set_zlabel('Z')

        os.makedirs(os.path.dirname(output_path), exist_ok=True)
        plt.savefig(output_path)
        print(f"Noise plot saved to PNG: {output_path}")
        plt.close(fig)
    except Exception as e:
        print(f"An error occurred while plotting noise points: {e}")


def analyze_energy_data(waters, labels, output_path):
    """
    Analyzes and writes energy data and cluster statistics to a text file.
    Includes a table of molecule counts per cluster, and statistics on free energy values.
    """
    try:
        os.makedirs(os.path.dirname(output_path), exist_ok=True)

        # Group energies by cluster label
        cluster_energies = {label: [] for label in np.unique(labels)}
        for i, water in enumerate(waters):
            if water['energy'] is not None:
                cluster_energies[labels[i]].append(water['energy'])

        total_molecules = len(waters)

        # Count molecules per cluster
        unique_labels, counts = np.unique(labels, return_counts=True)
        cluster_counts = dict(zip(unique_labels, counts))

        with open(output_path, 'w') as f:
            f.write("DBSCAN Cluster Statistics and Energy Analysis\n")
            f.write("==============================================\n\n")

            f.write("Cluster Membership Count:\n")
            f.write("-------------------------\n")
            f.write(f"Total Molecules Processed: {total_molecules}\n")

            f.write("\nCluster ID | Number of Molecules\n")
            f.write("--------------------------------\n")
            for cluster_id, count in cluster_counts.items():
                cluster_name = "Noise" if cluster_id == -1 else f"Cluster {cluster_id}"
                f.write(f"{cluster_name.ljust(11)}| {str(count).ljust(20)}\n")

            f.write("\n\nSzmap Neut Diff Free Energy Statistics by Cluster:\n")
            f.write("---------------------------------------------------\n")

            sorted_labels = sorted(cluster_energies.keys())

            for cluster_id in sorted_labels:
                energies = cluster_energies[cluster_id]
                cluster_name = "Noise" if cluster_id == -1 else f"Cluster {cluster_id}"

                num_positive_energies = sum(1 for e in energies if e > 0)
                num_negative_energies = sum(1 for e in energies if e < 0)
                num_zero_energies = sum(1 for e in energies if e == 0)
                mean_energy = np.mean(energies) if energies else 0

                f.write(f"\n--- {cluster_name} ---\n")
                f.write(f"  Number of Molecules: {len(energies)}\n")
                f.write(f"  Number of Positive Energies: {num_positive_energies}\n")
                f.write(f"  Number of Negative Energies: {num_negative_energies}\n")
                f.write(f"  Number of Zero Energies: {num_zero_energies}\n")
                f.write(f"  Mean Energy: {mean_energy:.4f}\n")
                f.write(f"  Full List of Energies: {energies}\n")

        print(f"Cluster statistics and energy analysis saved to: {output_path}")

    except Exception as e:
        print(f"An error occurred while analyzing energy data: {e}")


def write_mean_sdf(waters, labels, output_path):
    """
    Creates an SDF file with one molecule per cluster, where the molecule's
    coordinates and energy are the mean values of all molecules in that cluster.
    """
    os.makedirs(os.path.dirname(output_path), exist_ok=True)

    unique_labels = [label for label in np.unique(labels) if label != -1]

    with open(output_path, 'w') as f:
        for cluster_id in unique_labels:
            cluster_indices = np.where(labels == cluster_id)[0]
            cluster_waters = [waters[i] for i in cluster_indices]

            if not cluster_waters:
                continue

            coords = np.array([w['coords'] for w in cluster_waters])
            energies = [w['energy'] for w in cluster_waters if w['energy'] is not None]

            mean_coords = np.mean(coords, axis=0)
            mean_energy = np.mean(energies) if energies else 0

            # Determine atom type based on mean energy
            atom_type = 'O' if mean_energy < 0 else 'C'

            # Construct a simple SDF block for the mean molecule
            sdf_block = f"""
  ChemDraw09020914042D

 1  0  0  0  0  0  0  0  0  0999 V2000
    {mean_coords[0]:.4f}    {mean_coords[1]:.4f}    {mean_coords[2]:.4f} {atom_type}   0  0  0  0  0  0  0  0  0  0  0  0
M  END
> <cluster_id>
{cluster_id}

> <szmap_neut_diff_free_energy>
{mean_energy:.4f}

$$$$
"""
            f.write(sdf_block.strip() + '\n')
    print(f"Mean cluster molecules saved to: {output_path}")


def write_representative_sdf(waters, labels, output_path):
    """
    Creates an SDF file with one representative molecule for each cluster,
    based on energy and probability values.
    """
    os.makedirs(os.path.dirname(output_path), exist_ok=True)

    unique_labels = [label for label in np.unique(labels) if label != -1]

    with open(output_path, 'w') as f:
        for cluster_id in unique_labels:
            cluster_indices = np.where(labels == cluster_id)[0]
            cluster_waters = [waters[i] for i in cluster_indices]

            if not cluster_waters:
                continue

            # Filter out molecules with no energy or probability data
            valid_molecules = [w for w in cluster_waters if w['energy'] is not None and w['probability'] is not None]
            if not valid_molecules:
                continue

            # Determine if most energies are positive or negative
            energies = [w['energy'] for w in valid_molecules]
            num_positive = sum(1 for e in energies if e > 0)
            num_negative = sum(1 for e in energies if e < 0)

            # Select the representative molecule
            best_molecule = None
            if num_negative > num_positive:
                # Most are negative, find lowest energy (most negative) and highest probability
                best_molecule = min(valid_molecules, key=lambda w: (w['energy'], -w['probability']))
            else:
                # Most are positive, find highest energy and highest probability
                best_molecule = max(valid_molecules, key=lambda w: (w['energy'], w['probability']))

            if best_molecule:
                # Determine atom type based on the representative molecule's energy
                atom_type = 'O' if best_molecule['energy'] < 0 else 'C'

                # Get the original SDF block and modify it
                lines = best_molecule['text'].split('\n')
                # Modify the atom line to change the atom type
                for i, line in enumerate(lines):
                    if ' O ' in line:
                        lines[i] = line.replace(' O ', f' {atom_type} ', 1)
                        break

                # Reconstruct the SDF block
                sdf_block = '\n'.join(lines)

                # Add cluster ID and energy/probability to the block
                sdf_block += f"""
> <cluster_id>
{cluster_id}

> <szmap_neut_diff_free_energy>
{best_molecule['energy']}

> <szmap_probability>
{best_molecule['probability']}

$$$$
"""
                f.write(sdf_block.strip() + '\n')

    print(f"Representative cluster molecules saved to: {output_path}")


# --- Main Execution ---
if __name__ == "__main__":
    print("Starting water clustering script...")

    # 1. Collect and parse all water molecule data
    all_waters = collect_all_water_data(INPUT_DIR)

    if not all_waters:
        print("No SDF files or water molecules found. Exiting.")
    else:
        # 2. Extract oxygen coordinates for clustering
        oxygen_coords = np.array([water['coords'] for water in all_waters])
        print(f"\nExtracted coordinates for {len(oxygen_coords)} water molecules.")

        # 3. Generate the K-distance graph to help find optimal eps
        print("Generating K-distance graph to help determine optimal EPS...")
        plot_k_distance(oxygen_coords, MIN_SAMPLES, OUTPUT_DIR)

        # 4. Perform DBSCAN clustering with the default parameters
        # This will create the output files you initially requested
        print(f"\nPerforming DBSCAN with default parameters (eps={EPS}, min_samples={MIN_SAMPLES})...")
        cluster_labels = perform_dbscan(oxygen_coords, EPS, MIN_SAMPLES)

        # 5. Write the results to the various output files
        write_clustered_sdf(all_waters, cluster_labels, OUTPUT_PATH_SDF)
        write_raw_labels(cluster_labels, OUTPUT_PATH_LABELS)
        write_cluster_csv(oxygen_coords, cluster_labels, OUTPUT_PATH_CSV)
        plot_clusters(oxygen_coords, cluster_labels, OUTPUT_PATH_PNG)

        # 6. Write the additional files as requested
        print("\nGenerating additional output files as requested...")
        write_clustered_sdf_no_noise(all_waters, cluster_labels, OUTPUT_PATH_SDF_CLUSTERS)
        write_noise_sdf(all_waters, cluster_labels, OUTPUT_PATH_SDF_NOISE)
        plot_clusters_without_noise(oxygen_coords, cluster_labels, OUTPUT_PATH_PNG_CLUSTERS)
        plot_noise_only(oxygen_coords, cluster_labels, OUTPUT_PATH_PNG_NOISE)

        # 7. Perform energy analysis and write to file
        print("Performing energy analysis...")
        analyze_energy_data(all_waters, cluster_labels, OUTPUT_PATH_STATS_TXT)

        # 8. Write the new SDF files
        print("\nCreating new SDF files with mean and representative molecules...")
        write_mean_sdf(all_waters, cluster_labels, OUTPUT_PATH_SDF_MEAN)
        write_representative_sdf(all_waters, cluster_labels, OUTPUT_PATH_SDF_REPRESENTATIVE)

    print("\nScript finished.")
