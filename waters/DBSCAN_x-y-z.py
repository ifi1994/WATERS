import os
import re
import numpy as np
from sklearn.cluster import DBSCAN
from sklearn.neighbors import NearestNeighbors
import pandas as pd
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from sklearn.preprocessing import StandardScaler

# --- Configuration ---
# Set the input and output directories as provided in the request.
INPUT_DIR = r"C:\Users\ifige\Documents\GitHub\SZMAP\szmap_unique_waters"
OUTPUT_DIR = r"C:\Users\ifige\Documents\GitHub\SZMAP\DBSCAN_results"
OUTPUT_FILENAME_SDF = "clustered_waters.sdf"
OUTPUT_FILENAME_LABELS = "cluster_labels.txt"
OUTPUT_FILENAME_CSV = "clustered_data.csv"
OUTPUT_FILENAME_PNG = "cluster_plot.png"
OUTPUT_PATH_SDF = os.path.join(OUTPUT_DIR, OUTPUT_FILENAME_SDF)
OUTPUT_PATH_LABELS = os.path.join(OUTPUT_DIR, OUTPUT_FILENAME_LABELS)
OUTPUT_PATH_CSV = os.path.join(OUTPUT_DIR, OUTPUT_FILENAME_CSV)
OUTPUT_PATH_PNG = os.path.join(OUTPUT_DIR, OUTPUT_FILENAME_PNG)

# New output filenames for separated data
OUTPUT_FILENAME_SDF_CLUSTERS = "clustered_waters_no_noise.sdf"
OUTPUT_FILENAME_SDF_NOISE = "noise_only.sdf"
OUTPUT_FILENAME_PNG_CLUSTERS = "clustered_waters_no_noise.png"
OUTPUT_FILENAME_PNG_NOISE = "noise_only.png"
OUTPUT_PATH_SDF_CLUSTERS = os.path.join(OUTPUT_DIR, OUTPUT_FILENAME_SDF_CLUSTERS)
OUTPUT_PATH_SDF_NOISE = os.path.join(OUTPUT_DIR, OUTPUT_FILENAME_SDF_NOISE)
OUTPUT_PATH_PNG_CLUSTERS = os.path.join(OUTPUT_DIR, OUTPUT_FILENAME_PNG_CLUSTERS)
OUTPUT_PATH_PNG_NOISE = os.path.join(OUTPUT_DIR, OUTPUT_FILENAME_PNG_NOISE)

# New output file for cluster stats and energy analysis
OUTPUT_FILENAME_STATS_TXT = "cluster_stats.txt"
OUTPUT_PATH_STATS_TXT = os.path.join(OUTPUT_DIR, OUTPUT_FILENAME_STATS_TXT)

# New SDF filenames for mean, representative, and normalized representative molecules
OUTPUT_FILENAME_SDF_MEAN = "mean_cluster_waters.sdf"
OUTPUT_PATH_SDF_MEAN = os.path.join(OUTPUT_DIR, OUTPUT_FILENAME_SDF_MEAN)
OUTPUT_FILENAME_SDF_REPRESENTATIVE = "representative_cluster_waters.sdf"
OUTPUT_PATH_SDF_REPRESENTATIVE = os.path.join(OUTPUT_DIR, OUTPUT_FILENAME_SDF_REPRESENTATIVE)
OUTPUT_FILENAME_SDF_NORMALIZED_REPRESENTATIVE = "normalized_cluster_waters.sdf"
OUTPUT_PATH_SDF_NORMALIZED_REPRESENTATIVE = os.path.join(OUTPUT_DIR, OUTPUT_FILENAME_SDF_NORMALIZED_REPRESENTATIVE)

# New PNG filenames for the cluster analysis results
OUTPUT_FILENAME_PNG_MEAN = "mean_cluster_analysis.png"
OUTPUT_FILENAME_PNG_REPRESENTATIVE = "representative_cluster_analysis.png"
OUTPUT_FILENAME_PNG_NORMALIZED = "normalized_cluster_analysis.png"
OUTPUT_PATH_PNG_MEAN = os.path.join(OUTPUT_DIR, OUTPUT_FILENAME_PNG_MEAN)
OUTPUT_PATH_PNG_REPRESENTATIVE = os.path.join(OUTPUT_DIR, OUTPUT_FILENAME_PNG_REPRESENTATIVE)
OUTPUT_PATH_PNG_NORMALIZED = os.path.join(OUTPUT_DIR, OUTPUT_FILENAME_PNG_NORMALIZED)

# DBSCAN parameters. These are crucial and may need to be tuned
# based on your data. 'eps' is the maximum distance between two samples
# for one to be considered as in the neighborhood of the other. 'min_samples'
# is the number of samples in a neighborhood for a point to be considered
# as a core point.
# You will likely need to adjust these values.
# IMPORTANT: Use the K-distance graph generated by this script to help
# determine a better EPS value. Look for the 'elbow' in the plot.
EPS = 0.5  # A reasonable starting value in Angstroms for water molecules
MIN_SAMPLES = 250  # Minimum number of waters to form a cluster

# New parameters for clustering with energy
# Set to True to include the free energy in the clustering process
# --- CHANGE: Set CLUSTER_WITH_ENERGY to False to perform clustering on coordinates only. ---
CLUSTER_WITH_ENERGY = False
# EPS value for clustering on scaled data. This value will be different
# from the spatial-only EPS.
EPS_SCALED = 0.5


# --- Data Processing Functions ---

def parse_sdf_file(filepath):
    """
    Parses a single SDF file to extract water molecule data.
    It returns a list of dictionaries, where each dictionary contains
    the raw text block of a water molecule, the coordinates of its
    oxygen atom, and its szmap_neut_diff_free_energy and szmap_probability values.
    """
    waters = []
    try:
        with open(filepath, 'r') as f:
            file_content = f.read()

        # Split the file content by the '$$$$' separator
        water_blocks = file_content.split('$$$$\n')

        for block in water_blocks:
            if not block.strip():
                continue

            lines = block.strip().split('\n')

            # Find the line containing the oxygen atom ('O')
            oxygen_line = None
            for line in lines:
                if ' O ' in line:  # Ensure we match the atom type 'O'
                    oxygen_line = line
                    break

            # Find the line containing the free energy
            energy_value = None
            probability_value = None
            for i, line in enumerate(lines):
                if "> <szmap_neut_diff_free_energy>" in line:
                    if i + 1 < len(lines):
                        try:
                            energy_value = float(lines[i + 1].strip())
                        except (ValueError, IndexError):
                            energy_value = None
                if "> <szmap_probability>" in line:
                    if i + 1 < len(lines):
                        try:
                            probability_value = float(lines[i + 1].strip())
                        except (ValueError, IndexError):
                            probability_value = None

            if oxygen_line:
                # --- CORRECTED COORDINATE EXTRACTION ---
                # Split the line by whitespace and convert the first three parts to floats
                parts = oxygen_line.strip().split()
                try:
                    coords = [float(parts[0]), float(parts[1]), float(parts[2])]
                except (ValueError, IndexError) as e:
                    print(f"Error parsing coordinates in block: {e}")
                    coords = None

                if coords:
                    waters.append({
                        'text': block.strip(),
                        'coords': coords,
                        'energy': energy_value,
                        'probability': probability_value
                    })
    except FileNotFoundError:
        print(f"Error: File not found at {filepath}")
    except Exception as e:
        print(f"An error occurred while parsing {filepath}: {e}")

    return waters


def collect_all_water_data(input_dir):
    """
    Iterates through all .sdf files in the input directory,
    parses each one, and aggregates all water data.
    """
    all_waters = []
    try:
        for filename in os.listdir(input_dir):
            if filename.endswith(".sdf"):
                filepath = os.path.join(input_dir, filename)
                print(f"Parsing file: {filepath}")
                all_waters.extend(parse_sdf_file(filepath))
    except FileNotFoundError:
        print(f"Error: Input directory not found at {input_dir}")
    except Exception as e:
        print(f"An error occurred while listing files in {input_dir}: {e}")

    return all_waters


def perform_dbscan(data, eps, min_samples, scale_data=False):
    """
    Performs DBSCAN clustering on the provided data.
    Optionally scales the data before clustering.
    Returns the cluster labels for each data point.
    """
    if scale_data:
        scaler = StandardScaler()
        scaled_data = scaler.fit_transform(data)
        db = DBSCAN(eps=eps, min_samples=min_samples)
        labels = db.fit_predict(scaled_data)
        return labels
    else:
        db = DBSCAN(eps=eps, min_samples=min_samples)
        labels = db.fit_predict(data)
        return labels


def write_clustered_sdf(waters, labels, output_path):
    """
    Writes the clustered water molecules to a new SDF file.
    The cluster label is added as a new data field for each molecule.
    A label of -1 indicates a noise point.
    """
    # Ensure the output directory exists
    os.makedirs(os.path.dirname(output_path), exist_ok=True)

    with open(output_path, 'w') as f:
        for i, water in enumerate(waters):
            f.write(water['text'])
            f.write('\n')

            # Add the cluster label to the SDF block
            cluster_id = labels[i]
            f.write(f"> <cluster_id>\n{cluster_id}\n\n")

            f.write('$$$$\n')
    print(f"\nClustering results saved to: {output_path}")


def write_raw_labels(labels, output_path):
    """
    Writes the raw DBSCAN cluster labels to a text file.
    """
    # Ensure the output directory exists
    os.makedirs(os.path.dirname(output_path), exist_ok=True)

    with open(output_path, 'w') as f:
        f.write("# This file contains the raw, default output of the DBSCAN algorithm\n")
        f.write("# as an array of cluster labels. Each number corresponds to a water\n")
        f.write("# molecule in the order they were processed.\n")
        f.write("# A label of -1 indicates a 'noise' point.\n\n")
        f.write(f"{list(labels)}\n")
    print(f"Raw cluster labels saved to: {output_path}")


def write_cluster_csv(coords, labels, output_path):
    """
    Saves the coordinates and cluster labels to a CSV file.
    """
    try:
        df = pd.DataFrame(coords, columns=['x', 'y', 'z'])
        df['cluster_id'] = labels
        os.makedirs(os.path.dirname(output_path), exist_ok=True)
        df.to_csv(output_path, index=False)
        print(f"Cluster data saved to CSV: {output_path}")
    except Exception as e:
        print(f"An error occurred while writing CSV file: {e}")


def plot_clusters(coords, labels, output_path):
    """
    Generates a 3D scatter plot of the clustered data and saves it to a PNG file.
    """
    try:
        fig = plt.figure(figsize=(10, 8))
        ax = fig.add_subplot(111, projection='3d')

        # Color points based on their cluster ID
        unique_labels = set(labels)
        # Use a more distinct colormap for a large number of clusters
        colors = plt.cm.turbo(np.linspace(0, 1, len(unique_labels)))

        for k, col in zip(unique_labels, colors):
            if k == -1:
                # Black color for noise points
                col = 'k'
                marker_size = 6
            else:
                marker_size = 20

            class_member_mask = (labels == k)

            xyz = coords[class_member_mask]

            ax.scatter(xyz[:, 0], xyz[:, 1], xyz[:, 2], c=[col], s=marker_size, label=f'Cluster {k}')

        ax.set_title(f'DBSCAN Clustering (eps={EPS}, min_samples={MIN_SAMPLES})')
        ax.set_xlabel('X')
        ax.set_ylabel('Y')
        ax.set_zlabel('Z')

        os.makedirs(os.path.dirname(output_path), exist_ok=True)
        plt.savefig(output_path)
        print(f"Cluster plot saved to PNG: {output_path}")
        plt.close(fig)

    except Exception as e:
        print(f"An error occurred while plotting: {e}")


def plot_k_distance(coords, min_samples, output_dir, scaled=False):
    """
    Generates and saves a K-distance graph to help determine the optimal eps value.
    The 'elbow' in the graph indicates a good eps value.
    """
    try:
        neigh = NearestNeighbors(n_neighbors=min_samples)
        distances, indices = neigh.fit(coords).kneighbors(coords)
        distances = np.sort(distances[:, min_samples - 1], axis=0)

        plt.figure(figsize=(12, 6))
        plt.plot(distances)
        title = f'K-Distance Graph (k = {min_samples})'
        if scaled:
            title += " (Scaled Data)"
        plt.title(title)
        plt.xlabel('Data Points sorted by distance')
        plt.ylabel(f'{min_samples}-th Nearest Neighbor Distance')
        plt.grid(True)

        plot_filename = 'k_distance_graph_scaled.png' if scaled else 'k_distance_graph.png'
        plot_path = os.path.join(output_dir, plot_filename)
        os.makedirs(os.path.dirname(plot_path), exist_ok=True)
        plt.savefig(plot_path)
        plt.close()
        print(f"\nK-distance graph saved to: {plot_path}")
        print("INSTRUCTION: Open this image and look for the 'elbow' (the point where the graph sharply bends).")
        print("The corresponding Y-axis value is a good candidate for your 'EPS' parameter.")
        print(f"Consider adjusting MIN_SAMPLES to explore different k-values.")

    except Exception as e:
        print(f"An error occurred while plotting the K-distance graph: {e}")


def write_clustered_sdf_no_noise(waters, labels, output_path):
    """
    Writes only the clustered water molecules (label != -1) to a new SDF file.
    """
    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    with open(output_path, 'w') as f:
        for i, water in enumerate(waters):
            if labels[i] != -1:
                f.write(water['text'])
                f.write('\n')
                f.write(f"> <cluster_id>\n{labels[i]}\n\n")
                f.write('$$$$\n')
    print(f"Clustered waters (without noise) saved to: {output_path}")


def write_noise_sdf(waters, labels, output_path):
    """
    Writes only the noise water molecules (label == -1) to a new SDF file.
    """
    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    with open(output_path, 'w') as f:
        for i, water in enumerate(waters):
            if labels[i] == -1:
                f.write(water['text'])
                f.write('\n')
                f.write(f"> <cluster_id>\n{labels[i]}\n\n")
                f.write('$$$$\n')
    print(f"Noise waters saved to: {output_path}")


def plot_clusters_without_noise(coords, labels, output_path, eps, min_samples):
    """
    Generates a 3D scatter plot of only the clustered points and saves it to a PNG file.
    """
    try:
        fig = plt.figure(figsize=(10, 8))
        ax = fig.add_subplot(111, projection='3d')

        clustered_mask = labels != -1
        clustered_coords = coords[clustered_mask]
        clustered_labels = labels[clustered_mask]

        if len(clustered_labels) > 0:
            unique_labels = sorted(list(set(clustered_labels)))
            colors = plt.cm.turbo(np.linspace(0, 1, len(unique_labels)))

            for i, k in enumerate(unique_labels):
                class_member_mask = (clustered_labels == k)
                xyz = clustered_coords[class_member_mask]
                ax.scatter(xyz[:, 0], xyz[:, 1], xyz[:, 2], c=[colors[i]], s=20, label=f'Cluster {k}')
        else:
            ax.text2D(0.5, 0.5, "No clusters found (all points are noise)", ha='center', va='center',
                      transform=ax.transAxes)

        ax.set_title(f'DBSCAN Clusters Only (eps={eps}, min_samples={min_samples})')
        ax.set_xlabel('X')
        ax.set_ylabel('Y')
        ax.set_zlabel('Z')

        os.makedirs(os.path.dirname(output_path), exist_ok=True)
        plt.savefig(output_path)
        print(f"Cluster plot (without noise) saved to PNG: {output_path}")
        plt.close(fig)
    except Exception as e:
        print(f"An error occurred while plotting clusters without noise: {e}")


def plot_noise_only(coords, labels, output_path, eps, min_samples):
    """
    Generates a 3D scatter plot of only the noise points and saves it to a PNG file.
    """
    try:
        fig = plt.figure(figsize=(10, 8))
        ax = fig.add_subplot(111, projection='3d')

        noise_mask = labels == -1
        noise_coords = coords[noise_mask]

        ax.scatter(noise_coords[:, 0], noise_coords[:, 1], noise_coords[:, 2], c='k', s=6)

        ax.set_title(f'DBSCAN Noise Points Only (eps={eps}, min_samples={min_samples})')
        ax.set_xlabel('X')
        ax.set_ylabel('Y')
        ax.set_zlabel('Z')

        os.makedirs(os.path.dirname(output_path), exist_ok=True)
        plt.savefig(output_path)
        print(f"Noise plot saved to PNG: {output_path}")
        plt.close(fig)
    except Exception as e:
        print(f"An error occurred while plotting noise points: {e}")


def analyze_energy_data(waters, labels, mean_data, representative_data, normalized_data, output_path):
    """
    Analyzes and writes energy and probability data and cluster statistics to a text file.
    Includes a table of molecule counts per cluster, and statistics on free energy and probability values.
    Now also includes lists of energies and probabilities, and details on representative molecules.
    """
    try:
        os.makedirs(os.path.dirname(output_path), exist_ok=True)

        # Group energies and probabilities by cluster label
        cluster_data = {label: {'energies': [], 'probabilities': [], 'molecules': []} for label in np.unique(labels)}
        for i, water in enumerate(waters):
            cluster_data[labels[i]]['molecules'].append(water)
            if water['energy'] is not None:
                cluster_data[labels[i]]['energies'].append(water['energy'])
            if water['probability'] is not None:
                cluster_data[labels[i]]['probabilities'].append(water['probability'])

        total_molecules = len(waters)

        with open(output_path, 'w') as f:
            f.write("DBSCAN Cluster Statistics and Detailed Analysis\n")
            f.write("===============================================\n\n")

            f.write(f"Total Molecules Processed: {total_molecules}\n")

            sorted_labels = sorted(cluster_data.keys())

            for cluster_id in sorted_labels:
                energies = cluster_data[cluster_id]['energies']
                probabilities = cluster_data[cluster_id]['probabilities']
                num_molecules = len(cluster_data[cluster_id]['molecules'])
                cluster_name = "Noise" if cluster_id == -1 else f"Cluster {cluster_id}"

                f.write(f"\n--- {cluster_name} ---\n")
                f.write(f"  Number of Molecules: {num_molecules}\n")

                if not energies:
                    f.write("  No energy data available for this cluster.\n")
                    continue

                num_positive_energies = sum(1 for e in energies if e > 0)
                num_negative_energies = sum(1 for e in energies if e < 0)
                mean_energy = np.mean(energies)
                mean_probability = np.mean(probabilities) if probabilities else 0

                f.write(f"  Energy and Probability Summary:\n")
                f.write(f"    - Number of Positive Energies: {num_positive_energies}\n")
                f.write(f"    - Number of Negative Energies: {num_negative_energies}\n")
                f.write(f"    - Mean Energy: {mean_energy:.4f}\n")
                f.write(f"    - Mean Probability: {mean_probability:.4f}\n")

                f.write("\n  List of Energies:\n")
                f.write(f"    {energies}\n")

                f.write("\n  List of Probabilities:\n")
                f.write(f"    {probabilities}\n")

                if cluster_id != -1:
                    f.write("\n  Representative Molecule Details:\n")

                    # Find and write mean molecule data
                    mean_mol = next((item for item in mean_data if item["cluster_id"] == cluster_id), None)
                    if mean_mol:
                        f.write(f"    - **Mean Molecule**:\n")
                        f.write(
                            f"      - Coordinates: ({mean_mol['coords'][0]:.2f}, {mean_mol['coords'][1]:.2f}, {mean_mol['coords'][2]:.2f})\n")
                        f.write(f"      - Energy: {mean_mol['energy']:.4f}\n")

                    # Find and write representative molecule data
                    rep_mol = next((item for item in representative_data if item["cluster_id"] == cluster_id), None)
                    if rep_mol:
                        f.write(f"    - **Energy-Based Representative Molecule**:\n")
                        f.write(
                            f"      - Coordinates: ({rep_mol['coords'][0]:.2f}, {rep_mol['coords'][1]:.2f}, {rep_mol['coords'][2]:.2f})\n")
                        f.write(f"      - Energy: {rep_mol['energy']:.4f}\n")

                    # Find and write normalized representative molecule data
                    norm_rep_mol = next((item for item in normalized_data if item["cluster_id"] == cluster_id), None)
                    if norm_rep_mol:
                        f.write(f"    - **Normalized Representative Molecule**:\n")
                        f.write(
                            f"      - Coordinates: ({norm_rep_mol['coords'][0]:.2f}, {norm_rep_mol['coords'][1]:.2f}, {norm_rep_mol['coords'][2]:.2f})\n")
                        f.write(f"      - Energy: {norm_rep_mol['energy']:.4f}\n")

        print(f"Cluster statistics and detailed analysis saved to: {output_path}")

    except Exception as e:
        print(f"An error occurred while analyzing energy data: {e}")


def write_mean_sdf(waters, labels, output_path):
    """
    Creates an SDF file with one molecule per cluster, where the molecule's
    coordinates and energy are the mean values of all molecules in that cluster.
    Returns a list of dictionaries with the cluster_id, coordinates, and energy for plotting.
    """
    os.makedirs(os.path.dirname(output_path), exist_ok=True)

    unique_labels = [label for label in np.unique(labels) if label != -1]
    plot_data = []

    with open(output_path, 'w') as f:
        for cluster_id in unique_labels:
            cluster_indices = np.where(labels == cluster_id)[0]
            cluster_waters = [waters[i] for i in cluster_indices]

            if not cluster_waters:
                continue

            coords = np.array([w['coords'] for w in cluster_waters])
            energies = [w['energy'] for w in cluster_waters if w['energy'] is not None]

            mean_coords = np.mean(coords, axis=0)
            mean_energy = np.mean(energies) if energies else 0

            # Determine atom type based on mean energy
            atom_type = 'O' if mean_energy < 0 else 'C'

            # Construct a simple SDF block for the mean molecule
            sdf_block = f"""
  ChemDraw09020914042D

 1  0  0  0  0  0  0  0  0  0999 V2000
    {mean_coords[0]:.4f}    {mean_coords[1]:.4f}    {mean_coords[2]:.4f} {atom_type}   0  0  0  0  0  0  0  0  0  0  0  0
M  END
> <cluster_id>
{cluster_id}

> <szmap_neut_diff_free_energy>
{mean_energy:.4f}

$$$$
"""
            f.write(sdf_block.strip() + '\n')

            plot_data.append({
                'cluster_id': cluster_id,
                'coords': mean_coords,
                'energy': mean_energy
            })

    print(f"Mean cluster molecules saved to: {output_path}")
    return plot_data


def write_representative_sdf(waters, labels, output_path):
    """
    Creates an SDF file with one representative molecule for each cluster,
    based on energy and probability values. This file only contains the oxygen
    atom to remove hydrogens as requested.
    Returns a list of dictionaries with the cluster_id, coords, and energy for plotting.
    """
    os.makedirs(os.path.dirname(output_path), exist_ok=True)

    unique_labels = [label for label in np.unique(labels) if label != -1]
    plot_data = []

    with open(output_path, 'w') as f:
        for cluster_id in unique_labels:
            cluster_indices = np.where(labels == cluster_id)[0]
            cluster_waters = [waters[i] for i in cluster_indices]

            # Filter out molecules with no energy or probability data
            valid_molecules = [w for w in cluster_waters if w['energy'] is not None and w['probability'] is not None]
            if not valid_molecules:
                continue

            # Determine if most energies are positive or negative
            energies = [w['energy'] for w in valid_molecules]
            num_negative = sum(1 for e in energies if e < 0)

            # Select the representative molecule
            best_molecule = None
            if num_negative > (len(energies) - num_negative):
                # More negative energies, find lowest energy (most negative) and highest probability
                best_molecule = min(valid_molecules, key=lambda w: (w['energy'], -w['probability']))
            else:
                # More positive or equal energies, find highest energy and highest probability
                best_molecule = max(valid_molecules, key=lambda w: (w['energy'], w['probability']))

            if best_molecule:
                # Get the atom type from the representative molecule's energy
                atom_type = 'O' if best_molecule['energy'] < 0 else 'C'

                # Construct a new SDF block with a single atom
                sdf_block = f"""
  ChemDraw09020914042D

 1  0  0  0  0  0  0  0  0  0999 V2000
    {best_molecule['coords'][0]:.4f}    {best_molecule['coords'][1]:.4f}    {best_molecule['coords'][2]:.4f} {atom_type}   0  0  0  0  0  0  0  0  0  0  0  0
M  END
> <cluster_id>
{cluster_id}

> <szmap_neut_diff_free_energy>
{best_molecule['energy']:.4f}

> <szmap_probability>
{best_molecule['probability']:.4f}

$$$$
"""
                f.write(sdf_block.strip() + '\n')

                plot_data.append({
                    'cluster_id': cluster_id,
                    'coords': best_molecule['coords'],
                    'energy': best_molecule['energy']
                })

    print(f"Representative cluster molecules saved to: {output_path}")
    return plot_data


def write_normalized_representative_sdf(waters, labels, output_path):
    """
    Creates an SDF file with one representative molecule for each cluster,
    based on a combined score of normalized energy and probability. The energy
    normalization is adjusted based on whether the majority of energies in the
    cluster are positive or negative.
    Returns a list of dictionaries with the cluster_id, coords, and energy for plotting.
    """
    os.makedirs(os.path.dirname(output_path), exist_ok=True)

    unique_labels = [label for label in np.unique(labels) if label != -1]
    plot_data = []

    with open(output_path, 'w') as f:
        for cluster_id in unique_labels:
            cluster_indices = np.where(labels == cluster_id)[0]
            cluster_waters = [waters[i] for i in cluster_indices]

            # Filter out molecules with no energy or probability data
            valid_molecules = [w for w in cluster_waters if w['energy'] is not None and w['probability'] is not None]
            if not valid_molecules:
                continue

            # Get all energies and probabilities for this cluster
            energies = [w['energy'] for w in valid_molecules]
            probabilities = [w['probability'] for w in valid_molecules]

            min_e, max_e = min(energies), max(energies)
            min_p, max_p = min(probabilities), max(probabilities)

            # Avoid division by zero if all values are the same
            range_e = max_e - min_e
            range_p = max_p - min_p

            # Determine if most energies are positive or negative
            num_negative = sum(1 for e in energies if e < 0)
            is_majority_negative = num_negative > (len(energies) - num_negative)

            # Calculate a combined score for each molecule
            scored_molecules = []
            for w in valid_molecules:
                # Normalize energy based on the majority type
                if is_majority_negative:
                    # Favorable (more negative) is closer to 1.0
                    norm_e = (min_e - w['energy']) / (min_e - max_e) if range_e != 0 else 0.5
                else:
                    # Favorable (more positive) is closer to 1.0
                    norm_e = (w['energy'] - min_e) / range_e if range_e != 0 else 0.5

                # Normalize probability: Higher is closer to 1.0
                norm_p = (w['probability'] - min_p) / range_p if range_p != 0 else 0.5

                # Combined score with equal weighting
                score = (norm_e + norm_p) / 2
                scored_molecules.append({'molecule': w, 'score': score})

            # Select the molecule with the highest combined score
            best_molecule = max(scored_molecules, key=lambda x: x['score'])['molecule']

            if best_molecule:
                # Get the atom type from the representative molecule's energy
                atom_type = 'O' if best_molecule['energy'] < 0 else 'C'

                # Construct a new SDF block with a single atom
                sdf_block = f"""
  ChemDraw09020914042D

 1  0  0  0  0  0  0  0  0  0999 V2000
    {best_molecule['coords'][0]:.4f}    {best_molecule['coords'][1]:.4f}    {best_molecule['coords'][2]:.4f} {atom_type}   0  0  0  0  0  0  0  0  0  0  0  0
M  END
> <cluster_id>
{cluster_id}

> <szmap_neut_diff_free_energy>
{best_molecule['energy']:.4f}

> <szmap_probability>
{best_molecule['probability']:.4f}

$$$$
"""
                f.write(sdf_block.strip() + '\n')

                plot_data.append({
                    'cluster_id': cluster_id,
                    'coords': best_molecule['coords'],
                    'energy': best_molecule['energy']
                })

    print(f"Normalized representative cluster molecules saved to: {output_path}")
    return plot_data


def plot_analysis_results(plot_data, title, output_path):
    """
    Generates a 3D scatter plot for the analysis results, with energy values as labels.
    """
    try:
        fig = plt.figure(figsize=(12, 10))
        ax = fig.add_subplot(111, projection='3d')

        if not plot_data:
            ax.text2D(0.5, 0.5, "No data to plot.", ha='center', va='center', transform=ax.transAxes)
        else:
            unique_labels = sorted([d['cluster_id'] for d in plot_data])
            colors = plt.cm.turbo(np.linspace(0, 1, len(unique_labels)))

            for i, d in enumerate(plot_data):
                cluster_id = d['cluster_id']
                coords = d['coords']
                energy = d['energy']
                color = colors[i]

                ax.scatter(coords[0], coords[1], coords[2], c=[color], s=100, label=f'Cluster {cluster_id}')
                # Adjusted position (z + 0.3) and fontsize (12) for better visibility
                ax.text(coords[0], coords[1], coords[2] + 0.3, f'{energy:.2f}', color='k', fontsize=12, ha='center')

        ax.set_title(title)
        ax.set_xlabel('X')
        ax.set_ylabel('Y')
        ax.set_zlabel('Z')

        os.makedirs(os.path.dirname(output_path), exist_ok=True)
        plt.savefig(output_path)
        print(f"Analysis plot saved to PNG: {output_path}")
        plt.close(fig)
    except Exception as e:
        print(f"An error occurred while plotting: {e}")


# --- Main Execution ---
if __name__ == "__main__":
    print("Starting water clustering script...")

    # 1. Collect and parse all water molecule data
    all_waters = collect_all_water_data(INPUT_DIR)

    if not all_waters:
        print("No SDF files or water molecules found. Exiting.")
    else:
        # 2. Prepare data for clustering
        if CLUSTER_WITH_ENERGY:
            # Combine spatial coordinates and energy into a single array
            clustering_data = []
            for water in all_waters:
                # Use energy value if available, otherwise default to 0.0
                energy = water['energy'] if water['energy'] is not None else 0.0
                clustering_data.append(water['coords'] + [energy])

            clustering_data = np.array(clustering_data)
            print(f"\nExtracted coordinates and energy for {len(clustering_data)} water molecules.")

            # 3. Generate the K-distance graph to help find optimal eps for scaled data
            print("Generating K-distance graph for scaled data to help determine optimal EPS...")
            # Scale data for the K-distance plot to find the appropriate EPS value
            scaler = StandardScaler()
            scaled_for_k_plot = scaler.fit_transform(clustering_data)
            plot_k_distance(scaled_for_k_plot, MIN_SAMPLES, OUTPUT_DIR, scaled=True)

            # 4. Perform DBSCAN clustering with the new parameters and scaled data
            print(f"\nPerforming DBSCAN with combined data (eps={EPS_SCALED}, min_samples={MIN_SAMPLES})...")
            cluster_labels = perform_dbscan(clustering_data, EPS_SCALED, MIN_SAMPLES, scale_data=True)

        else:
            # Only use spatial coordinates for clustering
            clustering_data = np.array([water['coords'] for water in all_waters])
            print(f"\nExtracted coordinates for {len(clustering_data)} water molecules.")

            # 3. Generate the K-distance graph to help find optimal eps for spatial data
            print("Generating K-distance graph for spatial data to help determine optimal EPS...")
            plot_k_distance(clustering_data, MIN_SAMPLES, OUTPUT_DIR, scaled=False)

            # 4. Perform DBSCAN clustering with spatial coordinates only
            print(f"\nPerforming DBSCAN with spatial data only (eps={EPS}, min_samples={MIN_SAMPLES})...")
            cluster_labels = perform_dbscan(clustering_data, EPS, MIN_SAMPLES, scale_data=False)

        # 5. Get cluster and noise counts
        num_clusters = len(np.unique([l for l in cluster_labels if l != -1]))
        num_noise = list(cluster_labels).count(-1)
        print(f"\nFound {num_clusters} clusters and {num_noise} noise points.")

        # 6. Write out the results
        write_clustered_sdf(all_waters, cluster_labels, OUTPUT_PATH_SDF)
        write_raw_labels(cluster_labels, OUTPUT_PATH_LABELS)
        write_cluster_csv(clustering_data[:, :3], cluster_labels, OUTPUT_PATH_CSV)

        # 7. Generate 3D scatter plots
        plot_clusters(clustering_data[:, :3], cluster_labels, OUTPUT_PATH_PNG)
        write_clustered_sdf_no_noise(all_waters, cluster_labels, OUTPUT_PATH_SDF_CLUSTERS)
        write_noise_sdf(all_waters, cluster_labels, OUTPUT_PATH_SDF_NOISE)
        plot_clusters_without_noise(clustering_data[:, :3], cluster_labels, OUTPUT_PATH_PNG_CLUSTERS,
                                    EPS if not CLUSTER_WITH_ENERGY else EPS_SCALED, MIN_SAMPLES)
        plot_noise_only(clustering_data[:, :3], cluster_labels, OUTPUT_PATH_PNG_NOISE,
                        EPS if not CLUSTER_WITH_ENERGY else EPS_SCALED, MIN_SAMPLES)

        # 8. Analyze and write out energy data and representative molecules
        mean_waters = write_mean_sdf(all_waters, cluster_labels, OUTPUT_PATH_SDF_MEAN)
        representative_waters = write_representative_sdf(all_waters, cluster_labels, OUTPUT_PATH_SDF_REPRESENTATIVE)
        normalized_representative_waters = write_normalized_representative_sdf(all_waters, cluster_labels,
                                                                             OUTPUT_PATH_SDF_NORMALIZED_REPRESENTATIVE)
        analyze_energy_data(all_waters, cluster_labels, mean_waters, representative_waters,
                            normalized_representative_waters, OUTPUT_PATH_STATS_TXT)

        # 9. Plot the analysis results
        plot_analysis_results(mean_waters, "Mean Cluster Locations and Energies", OUTPUT_PATH_PNG_MEAN)
        plot_analysis_results(representative_waters, "Energy-Based Representative Molecules",
                              OUTPUT_PATH_PNG_REPRESENTATIVE)
        plot_analysis_results(normalized_representative_waters, "Normalized Score Representative Molecules",
                              OUTPUT_PATH_PNG_NORMALIZED)

    print("\nScript finished. All files saved to the output directory.")
